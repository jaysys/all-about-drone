ì•„FreeRTOSì—ì„œ Task ê°„ í†µì‹ ê³¼ ë°ì´í„° ê³µìœ ì— ì‚¬ìš©ë˜ëŠ” **Queue**, **Shared Struct + Mutex**, **EventGroup** ë°©ì‹ë“¤ì„ **ë¹„êµ ì„¤ëª…í•œ í‘œ**ì…ë‹ˆë‹¤.

---

### ğŸ“Š FreeRTOS í†µì‹ /ë™ê¸°í™” ë°©ì‹ ë¹„êµ í…Œì´ë¸”

| í•­ëª©               | **Queue** (í)                     | **Shared Struct + Mutex** (ê³µìœ êµ¬ì¡°ì²´ + ë®¤í…ìŠ¤)      | **EventGroup** (ì´ë²¤íŠ¸ ê·¸ë£¹)                    |
| ------------------ | ---------------------------------- | ---------------------------------------------------- | ----------------------------------------------- |
| **ì£¼ìš” ìš©ë„**      | Task ê°„ ë°ì´í„° ì „ë‹¬                | Task ê°„ ìƒíƒœ/ë°ì´í„° ê³µìœ                              | Task ê°„ ì´ë²¤íŠ¸ ì‹ í˜¸ ì „ë‹¬                        |
| **ë°ì´í„° ì „ë‹¬**    | âœ… ê°’ ë³µì‚¬í•˜ì—¬ ì „ë‹¬ (ì„ ì…ì„ ì¶œ)     | âŒ ì§ì ‘ ì ‘ê·¼ (í¬ì¸í„° ê¸°ë°˜, ë³µì‚¬ ì•„ë‹˜)                | âŒ ì´ë²¤íŠ¸ ë¹„íŠ¸ë§Œ ì „ë‹¬ (ë°ì´í„° ì—†ìŒ)             |
| **ì‹¤ì‹œê°„ì„±**       | âœ… ì‹ ë¢°ì„± ë†’ìŒ (ë²„í¼ì— ì ì¬)       | âœ… ë§¤ìš° ë¹ ë¦„ (ë‹¨ìˆœ ë©”ëª¨ë¦¬ ì ‘ê·¼)                      | âœ… ë§¤ìš° ë¹ ë¦„ (ë¹„íŠ¸ ë§ˆìŠ¤í¬ ì—°ì‚°)                 |
| **ë©”ëª¨ë¦¬ ì‚¬ìš©**    | ì¤‘ê°„                               | ë‚®ìŒ                                                 | ë§¤ìš° ë‚®ìŒ                                       |
| **íƒ€ì… ìœ ì—°ì„±**    | âœ… ë‹¤ì–‘í•œ êµ¬ì¡°ì²´ íƒ€ì… ì‚¬ìš© ê°€ëŠ¥    | âœ… ììœ ë¡­ê²Œ ì„¤ê³„ ê°€ëŠ¥                                | âŒ ë‹¨ìˆœ ì •ìˆ˜(ë¹„íŠ¸) ê¸°ë°˜                         |
| **ë³µìˆ˜ Task ì§€ì›** | âœ… ì—¬ëŸ¬ ì†¡ì‹ /ìˆ˜ì‹  Task ê°€ëŠ¥        | âš ï¸ ì§ì ‘ ì„¤ê³„ í•„ìš”                                    | âœ… ì—¬ëŸ¬ Taskê°€ í•˜ë‚˜ì˜ ë¹„íŠ¸ë¥¼ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆìŒ     |
| **ì„ ì…ì„ ì¶œ(FIFO)** | âœ… ì§€ì›                            | âŒ ì—†ìŒ                                              | âŒ ì—†ìŒ                                         |
| **ì‚¬ìš© ì˜ˆì‹œ**      | ì„¼ì„œ â†’ ì œì–´, ëª…ë ¹ â†’ ì œì–´ ë“±        | ê³µìœ  ìƒíƒœ: ì„¼ì„œê°’, ëª¨í„° ì¶œë ¥ ë“±                      | "ëª…ë ¹ ìˆ˜ì‹ ë¨", "ì„¼ì„œ ì´ˆê¸°í™” ì™„ë£Œ" ë“±            |
| **ì œí•œ ì‚¬í•­**      | í ê¸¸ì´ ì´ˆê³¼ ì‹œ block ë˜ëŠ” discard | ë™ì‹œ ì ‘ê·¼ ì‹œ mutex í•„ìˆ˜                              | ìµœëŒ€ 24\~32 ë¹„íŠ¸ ì œí•œ                           |
| **API ì˜ˆì‹œ**       | `xQueueSend()`, `xQueueReceive()`  | `xSemaphoreTake()`, `xSemaphoreGive()` + êµ¬ì¡°ì²´ ì ‘ê·¼ | `xEventGroupSetBits()`, `xEventGroupWaitBits()` |

---

### âœ… ìš”ì•½ ì¶”ì²œ

| ëª©ì                                  | ì¶”ì²œ ë°©ì‹             |
| ------------------------------------ | --------------------- |
| **ëª…ë ¹ ì „ì†¡ (ex. BLE â†’ ì œì–´ Task)**  | Queue                 |
| **ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„° ê³µìœ **          | Shared Struct + Mutex |
| **ìƒíƒœ ì´ë²¤íŠ¸ ì „ë‹¬ (ex. ì—°ê²° ëŠê¹€)** | EventGroup            |
| **ë²„íŠ¼ ëˆ„ë¦„ ê°ì§€ / í”Œë˜ê·¸ ì²˜ë¦¬**     | EventGroup            |
| **ì—¬ëŸ¬ Task ê°„ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì „íŒŒ**   | EventGroup            |

---

### ğŸ“Œ ì˜ˆì‹œ ìƒí™©ì— ë”°ë¥¸ ì„ íƒ

| ì˜ˆì‹œ ìƒí™©                                            | ì‚¬ìš© ë°©ì‹               | ì„¤ëª…                                     |
| ---------------------------------------------------- | ----------------------- | ---------------------------------------- |
| RC ìˆ˜ì‹ ê¸°ì—ì„œ ìˆ˜ì‹ ëœ ëª…ë ¹ì„ ì œì–´ Taskì— ì „ë‹¬         | `Queue`                 | ì—¬ëŸ¬ ëª…ë ¹ì´ ì—°ì† ë“¤ì–´ì˜¤ëŠ” ê²½ìš° FIFO ìœ ì§€ |
| IMUì—ì„œ ì½ì€ ê°’ì„ Stabilizerì™€ Telemetryê°€ í•¨ê»˜ ì°¸ì¡° | `Shared Struct + Mutex` | ìµœì‹ ê°’ë§Œ ìœ ì§€ë˜ë©´ ë¨ (ì´ì „ ê°’ ë¶ˆí•„ìš”)    |
| GPS ê³ ì • ì™„ë£Œë¨ â†’ ë‹¤ë¥¸ Taskë“¤ì— ì•Œë¦¼                 | `EventGroup`            | ì—¬ëŸ¬ Taskê°€ ë™ì‹œì— ê¸°ë‹¤ë¦´ ìˆ˜ ìˆìŒ        |

---

FreeRTOSì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ì„¸ ê°€ì§€ Task ê°„ í†µì‹ /ë™ê¸°í™” ë°©ì‹ì¸ **Queue**, **Shared Struct + Mutex**, **EventGroup** ê°ê°ì˜ **ê°„ë‹¨í•œ ìƒ˜í”Œ ì½”ë“œ ì˜ˆì‹œ**ì…ë‹ˆë‹¤.

---

## âœ… 1. Queue: **ëª…ë ¹ ì „ë‹¬ (ì˜ˆ: CommandTask â†’ StabilizerTask)**

```cpp
QueueHandle_t cmdQueue;

void TaskCommand(void *pv) {
  int command = 42;  // ì˜ˆì‹œ ëª…ë ¹ ì½”ë“œ
  while (true) {
    xQueueSend(cmdQueue, &command, portMAX_DELAY);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

void TaskStabilizer(void *pv) {
  int received;
  while (true) {
    if (xQueueReceive(cmdQueue, &received, portMAX_DELAY)) {
      Serial.print("ëª…ë ¹ ìˆ˜ì‹ : "); Serial.println(received);
    }
  }
}

void setup() {
  Serial.begin(115200);
  cmdQueue = xQueueCreate(5, sizeof(int));
  xTaskCreate(TaskCommand, "Cmd", 2048, NULL, 1, NULL);
  xTaskCreate(TaskStabilizer, "Stab", 2048, NULL, 1, NULL);
}
```

---

## âœ… 2. Shared Struct + Mutex: **ì„¼ì„œ ë°ì´í„°ë¥¼ ì—¬ëŸ¬ Taskê°€ ê³µìœ **

```cpp
typedef struct {
  float pitch;
  float roll;
  float yaw;
} Attitude;

Attitude imuData;
SemaphoreHandle_t dataMutex;

void TaskSensor(void *pv) {
  while (true) {
    xSemaphoreTake(dataMutex, portMAX_DELAY);
    imuData.pitch += 0.1;
    imuData.roll += 0.2;
    imuData.yaw += 0.3;
    xSemaphoreGive(dataMutex);
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
}

void TaskTelemetry(void *pv) {
  Attitude localCopy;
  while (true) {
    xSemaphoreTake(dataMutex, portMAX_DELAY);
    localCopy = imuData;
    xSemaphoreGive(dataMutex);
    Serial.printf("Pitch: %.2f, Roll: %.2f, Yaw: %.2f\n",
      localCopy.pitch, localCopy.roll, localCopy.yaw);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);
  dataMutex = xSemaphoreCreateMutex();
  xTaskCreate(TaskSensor, "Sensor", 2048, NULL, 1, NULL);
  xTaskCreate(TaskTelemetry, "Telem", 2048, NULL, 1, NULL);
}
```

---

## âœ… 3. EventGroup: **ì´ë²¤íŠ¸ ì‹ í˜¸ ì „ë‹¬ (ì˜ˆ: GPS ê³ ì • â†’ ë‹¤ë¥¸ Task ì•Œë¦¼)**

```cpp
EventGroupHandle_t systemEvents;
#define GPS_FIX_BIT (1 << 0)

void TaskGPS(void *pv) {
  vTaskDelay(3000 / portTICK_PERIOD_MS);  // GPS ê³ ì • ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
  xEventGroupSetBits(systemEvents, GPS_FIX_BIT);
  Serial.println("GPS Fix ì™„ë£Œ!");
  vTaskDelete(NULL);  // 1íšŒì„± ì´ë²¤íŠ¸ í›„ ì¢…ë£Œ
}

void TaskStabilizer(void *pv) {
  EventBits_t bits;
  while (true) {
    bits = xEventGroupWaitBits(systemEvents, GPS_FIX_BIT, false, true, portMAX_DELAY);
    if (bits & GPS_FIX_BIT) {
      Serial.println("GPS ê³ ì •ë¨ â†’ ìì„¸ì œì–´ ì‹œì‘");
      // ì´í›„ ì •ìƒ ë£¨í”„ ì‹¤í–‰...
      break;
    }
  }
  while (true) {
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);
  systemEvents = xEventGroupCreate();
  xTaskCreate(TaskGPS, "GPS", 2048, NULL, 1, NULL);
  xTaskCreate(TaskStabilizer, "Stab", 2048, NULL, 1, NULL);
}
```

---

## ì •ë¦¬

| ëª©ì                      | ë°©ì‹           | ì½”ë“œ ê¸°ëŠ¥                      |
| ------------------------ | -------------- | ------------------------------ |
| ëª…ë ¹ ì „ë‹¬ (FIFO)         | `Queue`        | ëª…ë ¹ì„ Task ê°„ ì „ë‹¬            |
| ì„¼ì„œê°’ ê³µìœ               | `Struct+Mutex` | ì„¼ì„œ ë°ì´í„°ë¥¼ ì—¬ëŸ¬ Taskê°€ ê³µìœ  |
| ìƒíƒœ/ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸ | `EventGroup`   | íŠ¹ì • ì´ë²¤íŠ¸ë¥¼ ì—¬ëŸ¬ Taskì— ì•Œë¦¼ |

---

# ğŸ“Œ **FreeRTOSì—ì„œ ì‚¬ìš©í•˜ëŠ” ë” ë³µì¡í•œ ì˜ˆì œ 3ê°€ì§€**

## âœ… 1. êµ¬ì¡°ì²´ Queue ì˜ˆì œ (ì„¼ì„œ â†’ ì œì–´ Task)

**ì„¼ì„œ ë°ì´í„° êµ¬ì¡°ì²´ë¥¼ Queueë¥¼ í†µí•´ ì „ë‹¬**í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

```cpp
struct SensorData {
  float pitch;
  float roll;
  float yaw;
};

QueueHandle_t sensorQueue;

void TaskSensor(void *pv) {
  SensorData data;
  while (true) {
    data.pitch += 0.1;
    data.roll  += 0.2;
    data.yaw   += 0.3;
    xQueueSend(sensorQueue, &data, portMAX_DELAY);
    vTaskDelay(10 / portTICK_PERIOD_MS);  // 100Hz
  }
}

void TaskStabilizer(void *pv) {
  SensorData received;
  while (true) {
    if (xQueueReceive(sensorQueue, &received, portMAX_DELAY)) {
      Serial.printf("[Stabilizer] Pitch: %.2f, Roll: %.2f, Yaw: %.2f\n",
        received.pitch, received.roll, received.yaw);
    }
  }
}

void setup() {
  Serial.begin(115200);
  sensorQueue = xQueueCreate(10, sizeof(SensorData));
  xTaskCreate(TaskSensor, "Sensor", 2048, NULL, 1, NULL);
  xTaskCreate(TaskStabilizer, "Stabilizer", 2048, NULL, 2, NULL);
}
```

---

## âœ… 2. ë³µìˆ˜ ì´ë²¤íŠ¸ ë™ê¸°í™” ì˜ˆì œ (GPS + RC ìˆ˜ì‹ ê¸° OK â†’ ë¹„í–‰ ì‹œì‘)

**EventGroupì—ì„œ ì—¬ëŸ¬ ì´ë²¤íŠ¸ê°€ ëª¨ë‘ ì„¤ì •ë˜ì—ˆì„ ë•Œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°€ëŠ” ë°©ì‹**ì…ë‹ˆë‹¤.

```cpp
EventGroupHandle_t flightEvents;
#define GPS_READY_BIT  (1 << 0)
#define RC_READY_BIT   (1 << 1)

void TaskGPS(void *pv) {
  vTaskDelay(2000 / portTICK_PERIOD_MS);
  Serial.println("ğŸ“¡ GPS Ready!");
  xEventGroupSetBits(flightEvents, GPS_READY_BIT);
  vTaskDelete(NULL);
}

void TaskRC(void *pv) {
  vTaskDelay(3000 / portTICK_PERIOD_MS);
  Serial.println("ğŸ“¶ RC Receiver Ready!");
  xEventGroupSetBits(flightEvents, RC_READY_BIT);
  vTaskDelete(NULL);
}

void TaskFlightController(void *pv) {
  // ë‘ ë¹„íŠ¸ ëª¨ë‘ ì„¤ì •ë  ë•Œê¹Œì§€ ëŒ€ê¸°
  EventBits_t bits = xEventGroupWaitBits(
    flightEvents,
    GPS_READY_BIT | RC_READY_BIT,
    false,   // ë¹„íŠ¸ë¥¼ ìœ ì§€
    true,    // ëª¨ë‘ ì„¤ì •ë˜ì–´ì•¼ í†µê³¼
    portMAX_DELAY
  );

  if ((bits & (GPS_READY_BIT | RC_READY_BIT)) == (GPS_READY_BIT | RC_READY_BIT)) {
    Serial.println("ğŸ›« Flight Controller: All systems ready. Taking off...");
  }

  while (true) {
    // ë©”ì¸ ë£¨í”„
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);
  flightEvents = xEventGroupCreate();
  xTaskCreate(TaskGPS, "GPS", 2048, NULL, 1, NULL);
  xTaskCreate(TaskRC, "RC", 2048, NULL, 1, NULL);
  xTaskCreate(TaskFlightController, "Flight", 4096, NULL, 2, NULL);
}
```

---

## âœ… 3. PID ì œì–´ ì˜ˆì œ (ì„¼ì„œê°’ â†’ PID ê³„ì‚° â†’ ëª¨í„° ì¶œë ¥)

**ê°„ë‹¨í•œ PID ì œì–´ ë£¨í”„ êµ¬í˜„ ì˜ˆ**ì…ë‹ˆë‹¤.

```cpp
struct SensorData {
  float pitch;
};
QueueHandle_t sensorQueue;

float targetPitch = 0.0;  // ëª©í‘œ ê°ë„

// PID íŒŒë¼ë¯¸í„°
float kp = 1.2, ki = 0.05, kd = 0.3;
float integral = 0, prevError = 0;

void TaskSensor(void *pv) {
  SensorData data;
  float theta = 0;
  while (true) {
    theta += 0.1;  // ì‹œë®¬ë ˆì´ì…˜
    data.pitch = theta;
    xQueueSend(sensorQueue, &data, portMAX_DELAY);
    vTaskDelay(10 / portTICK_PERIOD_MS);  // 100Hz
  }
}

void TaskPID(void *pv) {
  SensorData input;
  while (true) {
    if (xQueueReceive(sensorQueue, &input, portMAX_DELAY)) {
      float error = targetPitch - input.pitch;
      integral += error;
      float derivative = error - prevError;
      prevError = error;

      float output = kp * error + ki * integral + kd * derivative;

      // ì¶œë ¥ (ì˜ˆì‹œ: ëª¨í„° PWM ê°’ ê³„ì‚°)
      Serial.printf("Pitch: %.2f â†’ PID Out: %.2f\n", input.pitch, output);
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);
  sensorQueue = xQueueCreate(10, sizeof(SensorData));
  xTaskCreate(TaskSensor, "Sensor", 2048, NULL, 1, NULL);
  xTaskCreate(TaskPID, "PID", 2048, NULL, 2, NULL);
}
```

---

## 3ê°€ì§€ ê³ ê¸‰ ì˜ˆì œ ìš”ì•½

| ì˜ˆì œ               | ê¸°ìˆ  í¬ì¸íŠ¸          | ì£¼ìš” ì‚¬ìš©ì²˜                 |
| ------------------ | -------------------- | --------------------------- |
| âœ… êµ¬ì¡°ì²´ Queue    | ë³µì¡í•œ ë°ì´í„° ì „ë‹¬   | ì„¼ì„œ â†’ ì œì–´                 |
| âœ… ë³µìˆ˜ EventGroup | ë™ì‹œ ì¡°ê±´ ë§Œì¡± ëŒ€ê¸°  | ì‹œìŠ¤í…œ ì´ˆê¸°í™” ëŒ€ê¸° ë“±       |
| âœ… PID ê³„ì‚° Task   | ì‹¤ì‹œê°„ ì œì–´ ì•Œê³ ë¦¬ì¦˜ | ìì„¸ ì•ˆì •í™”, ìŠ¤ë¡œí‹€ ì œì–´ ë“± |

# ğŸ“Œ ì¶”ê°€ ì˜ˆì œ

- **ì—¬ëŸ¬ ì¶•(Pitch, Roll, Yaw)ì˜ PID ë™ì‹œ ì œì–´ êµ¬ì¡°**
- **PIDì™€ ëª¨í„° ë¯¹ì‹± ê²°í•©**
- **ì‹¤ì œ IMUì„¼ì„œ(MPU6050 ë“±)ì™€ ê²°í•© ì˜ˆì œ**

## âœ… 1ë‹¨ê³„: **ì—¬ëŸ¬ ì¶•(Pitch, Roll, Yaw)ì˜ PID ë™ì‹œ ì œì–´ êµ¬ì¡°**

**ì„¤ëª…**:
ê° ì¶•ë§ˆë‹¤ ë…ë¦½ì ì¸ PID ë£¨í”„ë¥¼ ë§Œë“¤ê³ , ì„¼ì„œ ë°ì´í„°(ìì´ë¡œ/ê°€ì†ë„ ë“±)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.

### ğŸ“„ êµ¬ì¡° ì˜ˆ

```cpp
struct Attitude {
  float pitch;
  float roll;
  float yaw;
};

struct PID {
  float kp, ki, kd;
  float integral;
  float prevError;
};

Attitude currentAttitude;
PID pidPitch = {1.0, 0.05, 0.2, 0, 0};
PID pidRoll  = {1.1, 0.04, 0.3, 0, 0};
PID pidYaw   = {0.8, 0.02, 0.15, 0, 0};

float computePID(PID &pid, float target, float current) {
  float error = target - current;
  pid.integral += error;
  float derivative = error - pid.prevError;
  pid.prevError = error;
  return pid.kp * error + pid.ki * pid.integral + pid.kd * derivative;
}

void TaskPID(void *pv) {
  float targetPitch = 0, targetRoll = 0, targetYaw = 0;
  while (true) {
    float outPitch = computePID(pidPitch, targetPitch, currentAttitude.pitch);
    float outRoll  = computePID(pidRoll, targetRoll, currentAttitude.roll);
    float outYaw   = computePID(pidYaw, targetYaw, currentAttitude.yaw);

    // ì—¬ê¸°ì„œ ëª¨í„°ë¯¹ì‹±ìœ¼ë¡œ ë„˜ì–´ê°ˆ ì¤€ë¹„
    Serial.printf("PID Out â†’ Pitch: %.2f, Roll: %.2f, Yaw: %.2f\n",
      outPitch, outRoll, outYaw);

    vTaskDelay(10 / portTICK_PERIOD_MS);  // 100Hz
  }
}
```

---

## âœ… 2ë‹¨ê³„: **PID ì¶œë ¥ â†’ ëª¨í„° ë¯¹ì‹± ê²°í•©**

**ì„¤ëª…**:
4ê°œì˜ ëª¨í„°ì— ëŒ€í•´ PID ì¶œë ¥ê°’ê³¼ ìŠ¤ë¡œí‹€(throttle)ì„ ì¡°í•©í•˜ì—¬ ê° ëª¨í„°ì˜ PWM ì¶œë ¥ê°’ì„ ë§Œë“­ë‹ˆë‹¤.

### ğŸ“„ êµ¬ì¡° ì˜ˆ (ì¿¼ë“œì½¥í„° X êµ¬ì„± ê¸°ì¤€)

```cpp
float throttle = 1300;  // ê¸°ë³¸ ìŠ¤ë¡œí‹€ (1000~2000 us)

void mixMotors(float pitchOut, float rollOut, float yawOut) {
  float motor1 = throttle + pitchOut - rollOut + yawOut;  // Front Left
  float motor2 = throttle + pitchOut + rollOut - yawOut;  // Front Right
  float motor3 = throttle - pitchOut + rollOut + yawOut;  // Rear Right
  float motor4 = throttle - pitchOut - rollOut - yawOut;  // Rear Left

  // ë²”ìœ„ ì œí•œ
  motor1 = constrain(motor1, 1000, 2000);
  motor2 = constrain(motor2, 1000, 2000);
  motor3 = constrain(motor3, 1000, 2000);
  motor4 = constrain(motor4, 1000, 2000);

  // ì¶œë ¥ (ì˜ˆ: ESC ì œì–´ìš© PWM ì‹ í˜¸)
  analogWrite(25, motor1);  // PWM ì±„ë„ì€ ì˜ˆì‹œ
  analogWrite(26, motor2);
  analogWrite(27, motor3);
  analogWrite(14, motor4);

  Serial.printf("Motors: %.1f %.1f %.1f %.1f\n", motor1, motor2, motor3, motor4);
}
```

ğŸ§  `TaskPID()` ë‚´ë¶€ ë§ˆì§€ë§‰ ì¤„ì— `mixMotors(outPitch, outRoll, outYaw);` í˜¸ì¶œì„ ë„£ìœ¼ë©´ ë©ë‹ˆë‹¤.

---

## âœ… 3ë‹¨ê³„: **MPU6050 ë“± IMU ì„¼ì„œì™€ ì‹¤ì œ ê²°í•©**

**ì„¤ëª…**:
MPU6050ì—ì„œ ê°€ì†ë„ + ìì´ë¡œ ë°ì´í„°ë¥¼ ì½ì–´ ìœµí•©í•˜ì—¬ Pitch/Roll/Yawë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

### ğŸ“¦ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•„ìš”

- [`MPU6050`](https://github.com/jrowberg/i2cdevlib) by Jeff Rowberg (i2cdevlib)
- ë˜ëŠ” `Adafruit_MPU6050` ë“±ë„ ê°€ëŠ¥

### ğŸ“„ ê°„ë‹¨í•œ MPU6050 ê¸°ë°˜ Attitude ê³„ì‚° ì˜ˆ

```cpp
#include <Wire.h>
#include <MPU6050.h>

MPU6050 mpu;

void TaskSensor(void *pv) {
  mpu.initialize();
  if (!mpu.testConnection()) {
    Serial.println("MPU6050 ì—°ê²° ì‹¤íŒ¨!");
    vTaskDelete(NULL);
  }

  while (true) {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    // ë‹¨ìˆœí•œ ê°ë„ ê³„ì‚° (í•„í„° ì—†ìŒ)
    currentAttitude.pitch = atan2(ay, az) * 180 / PI;
    currentAttitude.roll  = atan2(ax, az) * 180 / PI;
    currentAttitude.yaw   += gz * 0.001;  // ì ë¶„(ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜)

    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
}
```

---

## ğŸ”„ ì¢…í•© ì—°ë™ íë¦„ë„

```plaintext
[MPU6050 Task]
   â†“ (currentAttitude ì—…ë°ì´íŠ¸)

[PID Task]
   â†’ Pitch PID
   â†’ Roll PID
   â†’ Yaw PID
   â†“

[Motor Mixer]
   â†’ Motor1~4 PWM ì¶œë ¥
```

---

## ë‹¤ìŒì— í•  ìˆ˜ ìˆëŠ” í™•ì¥

- `Madgwick` or `Complementary Filter` ì ìš©ìœ¼ë¡œ ì„¼ì„œ ìœµí•© ì •ë°€ë„ í–¥ìƒ
- `Queue`ë¥¼ í†µí•´ ì„¼ì„œ Task â†” PID Task ë¶„ë¦¬
- `ESC ìº˜ë¦¬ë¸Œë ˆì´ì…˜`, `Arm/Disarm`, `Failsafe`, `RC ëª…ë ¹` ë“± ë„ì…
- `MPU6050 DMP ëª¨ë“œ`ë¥¼ ì´ìš©í•œ ìë™ ìœµí•© í™œìš©

---

ë” íŒŒì•…í•´ë´ì•¼í•  ê²ƒë“¤... ì­‰~~

- ì„¼ì„œê°’ì„ PID Taskì— Queueë¡œ ì „ë‹¬í•˜ëŠ” êµ¬ì¡°
- ëª¨í„° PWM ì¶œë ¥ êµ¬ì¡° ìì„¸íˆ êµ¬ì„±
- ì„¼ì„œ ìœµí•© í•„í„° ì ìš© ì˜ˆ (Complementary or Madgwick)
